//To  compile,
//g++ Password_encryption.cpp -I /usr/local/include -L /usr/local/lib/ -lcryptopp

#include <iostream>
#include <iomanip>
#include <fstream>
#include <cryptopp/modes.h>
#include <cryptopp/aes.h>
#include <cryptopp/filters.h>
#include <cryptopp/hex.h>
#include <cryptopp/osrng.h>
#include <cryptopp/secblock.h>
// DEFAULT_KEYLENGTH= 16 bytes
//BLOCKSIZE For AES is 16 bytes.
using namespace std;

std::string EncAES( std::string plain, byte* key, byte* iv ){

    CryptoPP::AES::Encryption aesEncryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption( aesEncryption, iv );
    //Cipher object initialization with key and random vector
    std::string ciphertext;
    //StreamTransformationFilter is used for padding and buffering of the data
    CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink( ciphertext ) );
    stfEncryptor.Put( reinterpret_cast<const unsigned char*>( plain.c_str() ), plain.length() );
    stfEncryptor.MessageEnd();

    byte cipher_byte[ciphertext.size()];
    std::string encoded;
    CryptoPP::HexEncoder encoder;
    //Hexencoder convert bytes into base 16 encoded data
    for( int i = 0; i < ciphertext.size(); i++ ) {
        cipher_byte[i] =  0xFF & static_cast<byte>(ciphertext[i]);
    }

    encoder.Put(cipher_byte, sizeof(cipher_byte));//put data into buffer for processing
    encoder.MessageEnd();
    CryptoPP::word64 size = encoder.MaxRetrievable();
    if(size)
    {
        encoded.resize(size);
        encoder.Get((byte*)&encoded[0], encoded.size());
    }

    return encoded;


}

std::string DecAES( std::string encString, byte* key, byte* iv){

    std::string decoded;
    std::string decryptedtext;
    CryptoPP::HexDecoder decoder;//Hexdecoder convert base 16 encoded data to bytes
    decoder.Put( (byte*)encString.data(), encString.size() );
    decoder.MessageEnd();

    CryptoPP::word64 sized = decoder.MaxRetrievable();
    if(sized && sized <= SIZE_MAX){
        decoded.resize(sized);
        decoder.Get((byte*)&decoded[0], decoded.size());
    }

   // std::cout << std::endl << decoded << std::endl;

    CryptoPP::AES::Decryption aesDecryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );

    CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedtext ) );
    stfDecryptor.Put( reinterpret_cast<const unsigned char*>( decoded.c_str() ), decoded.size() );
    stfDecryptor.MessageEnd();

    return decryptedtext;
}

int main() {

    byte shared_key[ CryptoPP::AES::DEFAULT_KEYLENGTH ];// Generate symmetric key for encryption
   /* CryptoPP::AutoSeededRandomPool rand_gen;
    rand_gen.GenerateBlock( shared_key, 16 );*/

    byte random_iv[ CryptoPP::AES::DEFAULT_KEYLENGTH ];// Generate initialization vector for encryption
    /*CryptoPP::AutoSeededRandomPool rand_gen_iv;
    rand_gen_iv.GenerateBlock( random_iv, 16 );*/

    memset( shared_key, 0xAA, CryptoPP::AES::DEFAULT_KEYLENGTH );
    memset( random_iv, 0xC9, CryptoPP::AES::BLOCKSIZE );

    byte Masterkey[ CryptoPP::AES::DEFAULT_KEYLENGTH ], Masteriv[ CryptoPP::AES::BLOCKSIZE ];
    memset( Masterkey, 0xF6, CryptoPP::AES::DEFAULT_KEYLENGTH );
    memset( Masteriv, 0xBB, CryptoPP::AES::BLOCKSIZE );

    std::string encDBPassWord;
    std::string decDBPassWord;
    std::string lines, ReadFromFileName, dbPassword;
    std::string EncPassword, EncMasterPassword;

    std::cout<<"\n Enter DB password to encrypt:-\t";// Reads db password from the user
    std::cin>>dbPassword;

    fstream MasterPassword_toRead;
    ReadFromFileName = "masterpasswd.cfg";
    MasterPassword_toRead.open(ReadFromFileName.c_str());
    while (MasterPassword_toRead >> lines)
    {
        std::size_t pos = lines.find("password");
        if ( pos != std::string::npos ){
            EncMasterPassword = lines.substr (pos+9);
            //std::cout << EncMasterPassword << std::endl;
        }
    }
    MasterPassword_toRead.close();
    std::string masterPassWord = DecAES( EncMasterPassword, Masterkey, Masteriv );

    std::cout<<"Master password is-"<<masterPassWord;
    //std::string masterPassWord = "wams";
    encDBPassWord = EncAES(  masterPassWord + dbPassword , shared_key, random_iv ); // Here wams is considered as a master password, one can change it.
    // The key and initialization vector is passed to encryption function

    // Replaces the password field with the encrypted string generated by AES
    //std::cout<< encDBPassWord << std::endl;
    std::ifstream DBPassword_toWrite("db.cfg");
    std::ofstream DBPassword_TempWrite("temp.cfg");
    while (getline(DBPassword_toWrite, lines))
    {
        size_t pos = lines.find("password");
        if (pos != string::npos)
            DBPassword_TempWrite << "password=" + encDBPassWord << "\n";
        else
            DBPassword_TempWrite << lines << "\n";
    }
    DBPassword_toWrite.close();
    DBPassword_TempWrite.close();
    remove("db.cfg");
    rename("temp.cfg","db.cfg");
    /*ofstream DBPassword_toWrite;
    DBPassword_toWrite.open("db.cfg",  std::ios_base::app);
    DBPassword_toWrite << "password="+ encDBPassWord <<"\n";
    DBPassword_toWrite.close();*/
    fstream DBPassword_toRead;
    ReadFromFileName = "db.cfg";
    //Reads encrypted password from the cfg file
    DBPassword_toRead.open(ReadFromFileName.c_str());
    while (DBPassword_toRead >> lines)
    {
        std::size_t pos = lines.find("password");
        if ( pos != std::string::npos ){
            EncPassword = lines.substr (pos+9);
            // std::cout << EncPassword << std::endl;
        }
    }

    //decrypted
    decDBPassWord = DecAES ( EncPassword, shared_key, random_iv );

    /* std::cout << "Decrypted Text: " << std::endl;
    std::cout << decDBPassWord;*/
    std::cout << std::endl<< "\n DB password is:-  "<< decDBPassWord.substr(masterPassWord.length(),dbPassword.length());
    std::cout << std::endl << std::endl;



    return 0;
}
